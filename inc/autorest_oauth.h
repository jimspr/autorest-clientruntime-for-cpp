// Code generated by Microsoft (R) AutoRest Code Generator 1.0.1.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
#pragma once
#include <autorest_json.h>
#include <autorest_util.h>
#include <string>
#include <optional>

namespace autorest::oauth
{
using namespace std;
using namespace awaituv;
using namespace awaitcurl;
using namespace rapidjson;
using namespace autorest::util;
using namespace autorest::json;

class bearer_token
{
public:
    optional<string> token_type;
    optional<string> expires_in;
    optional<string> ext_expires_in;
    optional<string> expires_on;
    optional<string> not_before;
    optional<guid_t> resource;
    optional<string> access_token;

    bearer_token()
    {
    }

#define JSO(var) \
        if(var.has_value())\
            result.AddMember(#var, autorest::json::json_serialize(var, allocator), allocator);
#define JDSO(var)\
        if (value.HasMember(#var))\
            autorest::json::json_deserialize(result.var, value[#var]);

    Value serialize(Value::AllocatorType& allocator) const
    {
        Value result(kObjectType);
        JSO(token_type);
        JSO(expires_in);
        JSO(ext_expires_in);
        JSO(expires_on);
        JSO(not_before);
        JSO(resource);
        JSO(access_token);
        return result;
    }

    static bearer_token deserialize(const char* payload)
    {
        Document d;
        d.Parse(payload);
        return deserialize(d);
    }
    static bearer_token deserialize(const Value& value)
    {
        bearer_token result;
        JDSO(token_type);
        JDSO(expires_in);
        JDSO(ext_expires_in);
        JDSO(expires_on);
        JDSO(not_before);
        JDSO(resource);
        JDSO(access_token);
        return result;
    }
    #undef JSO
    #undef JDSO
};

future_t<http_response<optional<bearer_token>>> get_azure_token_using_client_credentials(curl_requester_t& root_handler, 
  const string& tenant, const string& client_id, const string& client_secret, const string& resource, cancellation_token_t cancellationToken)
{
    auto curl = curl_easy_init();
    if (tenant.empty())
        throw validation_exception_t{};
    // Construct URL
    string _url = "https://login.microsoftonline.com/{tenant}/oauth2/token";
    replace_in_string(_url, "{tenant}", escape_data_string(curl, tenant.c_str()));

    if (root_handler.verbose)
        curl_easy_setopt(curl, CURLOPT_VERBOSE);
    curl_easy_setopt(curl, CURLOPT_URL, _url.c_str());
    curl_easy_setopt(curl, CURLOPT_HTTPPOST);
    // Set Headers

    struct curl_slist *sheaders = nullptr;
    sheaders = curl_slist_append(sheaders, "accept: application/json");
    sheaders = curl_slist_append(sheaders, "content-type: application/x-www-form-urlencoded; charset=utf-8");
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, sheaders);

    string body = string("grant_type=client_credentials&client_id=") + client_id 
      + "&client_secret=" + client_secret;
    if (!resource.empty())
      body += string("&resource=") + escape_data_string(curl, resource.c_str());
    
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, body.size());
    curl_easy_setopt(curl, CURLOPT_COPYPOSTFIELDS, body.c_str());
    
    rapidjson::MemoryPoolAllocator<> allocator;
    cancellationToken.throw_if_cancellation_requested();
    http_response<optional<bearer_token>> _httpResponse = co_await root_handler.invoke(curl);
    cancellationToken.throw_if_cancellation_requested();
    // Dispatch based on response
    switch (_httpResponse.http_code)
    {
    case 200:
        rapidjson::Document d;
        d.Parse(_httpResponse.str.c_str());
        _httpResponse.object = json_deserialize<bearer_token>(d);
        break;
    }
    curl_easy_cleanup(curl);
    //return _result;
    return _httpResponse;
}

}